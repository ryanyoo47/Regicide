<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Ryan's Regicide</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0b0f14">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  :root{--bg:#0b0f14;--panel:#151c24;--accent:#4da3ff;--text:#e9f2ff;--muted:#9fb4cc;--danger:#ff5d6c;--warn:#ffd166}
  *{box-sizing:border-box}
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;background:#0b0f14;color:var(--text)}
  header{position:sticky;top:0;background:#0c121a;z-index:10;border-bottom:1px solid #1b2633;padding:10px 14px;display:flex;gap:10px;justify-content:space-between;align-items:center}
  h1{font-size:18px;margin:0}
  .btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:700;color:#051017;background:var(--accent)}
  .btn.secondary{background:#1a2533;color:#cfe8ff;border:1px solid #27364a}
  .btn.warn{background:var(--warn)} .btn.danger{background:var(--danger)}
  .container{padding:12px}
  .panel{background:var(--panel);border:1px solid #1a2431;border-radius:16px;padding:12px;margin-bottom:12px}
  .section-title{font-size:13px;text-transform:uppercase;letter-spacing:.15em;color:var(--muted);margin:0 0 6px}
  .enemy{display:flex;gap:12px;align-items:center}
  .stat{background:#0e141c;border:1px solid #1f2a3a;padding:10px;border-radius:12px;min-width:84px;text-align:center}
  .stat .label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.18em}
  .stat .value{font-size:18px;font-weight:800;margin-top:4px}
  .meter{height:10px;background:#0c1320;border:1px solid #1b2740;border-radius:999px;overflow:hidden}
  .meter > i{display:block;height:100%;background:linear-gradient(90deg,#4da3ff,#5dffaa);width:0%}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #213146;background:#0e1520;color:var(--muted);font-size:12px}
  .pile{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pile .card-back,.card{width:68px;height:96px;border-radius:12px;border:2px solid #2a3b53;background:linear-gradient(180deg,#182434,#0f1826);display:grid;place-items:center;font-weight:800;box-shadow:0 2px 0 rgba(0,0,0,.4)}
  .card-back::after{content:"🂠";font-size:20px;filter:drop-shadow(0 1px 0 #000)}
  .counts{font-size:12px;color:var(--muted)}
  .hand{display:flex;gap:10px;overflow-x:auto;padding:10px 6px;min-height:110px;background:rgba(255,255,255,.03);border-radius:12px;border:1px solid #1a2431}
  .card{position:relative;user-select:none}
  .card .rank{position:absolute;left:6px;top:6px;font-size:16px;font-weight:900;text-shadow:0 1px 0 #000}
  .card .suit{font-size:26px;filter:drop-shadow(0 1px 0 #000)}
  .card.red{color:#ffd0d8} .card.black{color:#e5f1ff}
  .card.selected{outline:3px solid var(--accent);transform:translateY(-4px)}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .log{max-height:36vh;overflow:auto;font-size:13px;line-height:1.35;padding-right:4px}
  .log p{margin:.4em 0}
  button,.btn{pointer-events:auto;touch-action:manipulation}
</style>
</head>
<body>
<header>
  <h1>Ryan's Regicide</h1>
  <button class="btn" id="newGameBtn">New Game</button>
</header>

<div class="container">
  <div class="panel">
    <p class="section-title">Enemy</p>
    <div class="enemy">
      <div class="card" id="enemyCard" aria-label="Enemy card">
        <div class="rank" id="enemyRank">J</div><div class="suit" id="enemySuit">♣</div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div class="stat"><div class="label">Health</div><div class="value" id="hpText">20</div><div class="meter"><i id="hpBar"></i></div></div>
        <div class="stat"><div class="label">Attack</div><div class="value" id="atkText">10</div><div class="label" id="shieldHint"></div></div>
      </div>
    </div>
    <div class="pile" style="margin-top:10px">
      <span class="badge">Immunity: <b id="immuneSuit">♣</b></span>
      <span class="badge">Spade shield: <b id="spadeShield">0</b></span>
      <span class="badge">Damage dealt: <b id="damageSoFar">0</b></span>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Tavern, Castle & Discard</p>
    <div class="pile">
      <div class="card-back"></div><div class="counts">Tavern: <b id="tavernCount">0</b></div>
      <div class="card-back"></div><div class="counts">Castle: <b id="castleCount">12</b></div>
      <div class="card-back"></div><div class="counts">Discard: <b id="discardCount">0</b></div>
      <span class="badge">Jester flips: <b id="jesterFlips">2</b></span>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Your Hand (tap to select) — <span class="counts">Count: <b id="handCount">0</b></span></p>
    <div class="hand" id="hand" aria-label="Your hand"></div>
    <div class="counts" id="handEmptyHint" style="display:none;margin-top:6px">Your hand is empty. Use ♦ draw or a Jester flip to refill to 8.</div>
  </div>

  <div class="panel">
    <p class="section-title">Actions</p>
    <div class="toolbar">
      <button class="btn" id="playBtn">Play Selected</button>
      <button class="btn secondary" id="yieldBtn">Yield (take damage)</button>
      <button class="btn warn" id="flipJesterBtn">Flip Jester</button>
      <button class="btn danger" id="undoBtn">Undo</button>
      <button class="btn secondary" id="rulesBtn">Rules</button>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Log</p>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
const SUITS = ["♣","♦","♥","♠"], COLORS = {"♣":"black","♠":"black","♦":"red","♥":"red"};
const RANKS = ["2","3","4","5","6","7","8","9","10","A"], ROYALS=["J","Q","K"];
const ENEMY_STATS = { "J":{hp:20,atk:10}, "Q":{hp:30,atk:15}, "K":{hp:40,atk:20} }, MAX_HAND=8;
const sum=a=>a.reduce((x,y)=>x+y,0), clone=o=>JSON.parse(JSON.stringify(o));
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a }
function cardValue(c){ if(ROYALS.includes(c.rank)) return c.rank==="J"?10:c.rank==="Q"?15:20; if(c.rank==="A") return 1; return parseInt(c.rank,10) }

function renderCard(c){
  const d=document.createElement("div");
  d.className=`card ${COLORS[c.suit]}`;
  d.dataset.id=c.id;
  d.innerHTML=`<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;
  d.addEventListener("click",()=>toggleSelect(c.id),{passive:true});
  return d;
}

// ---- State & helpers ----
let S=null, HISTORY=[];
function pushHistory(){ HISTORY.push(clone(S)); if(HISTORY.length>80) HISTORY.shift() }
function undo(){ if(HISTORY.length){ S=HISTORY.pop(); syncUI(true) } }
function selected(){ return S.hand.filter(c=>S.selectedIds.includes(c.id)) }
function clearSel(){ S.selectedIds=[] }
function enemyImmuneSuit(){ return S.enemy.suit }
function currentEnemyStats(){ const b=ENEMY_STATS[S.enemy.rank]; return {hp:b.hp, atk:Math.max(0, b.atk - S.spadeShield)} }

function newGame(){
  const j=shuffle(SUITS.map(s=>({rank:"J",suit:s,id:`J${s}`})));
  const q=shuffle(SUITS.map(s=>({rank:"Q",suit:s,id:`Q${s}`})));
  const k=shuffle(SUITS.map(s=>({rank:"K",suit:s,id:`K${s}`})));
  const castle=[...j,...q,...k];

  let tavern=[];
  for(const r of RANKS){ for(const s of SUITS){ tavern.push({rank:r,suit:s,id:`${r}${s}-${Math.random().toString(36).slice(2,7)}`}) } }
  shuffle(tavern);

  const hand=[]; while(hand.length<MAX_HAND && tavern.length) hand.push(tavern.shift());

  S={ tavern, castle, discard:[], hand,
      enemy: clone(castle[0]), enemyDamage:0, spadeShield:0, jesterFlips:2, selectedIds:[] };
  logClear(); log(`New game. First enemy: ${S.enemy.rank}${S.enemy.suit}.`);
  syncUI();
}

function toggleSelect(id){
  const i=S.selectedIds.indexOf(id);
  if(i>=0) S.selectedIds.splice(i,1); else S.selectedIds.push(id);
  syncUI(true);
}

function isComboSameRank(cards){
  if(cards.length<2) return false;
  const rr=[...new Set(cards.map(c=>c.rank))];
  if(rr.length!==1) return false;
  if(rr[0]==="A" || ROYALS.includes(rr[0])) return false;
  return sum(cards.map(cardValue))<=10;
}

function isValidPlay(cards){
  if(!cards.length) return false;
  if(cards.length===1) return true;
  const hasA=cards.some(c=>c.rank==="A");
  if(cards.length===2){
    if(hasA){ const other=cards.find(c=>c.rank!=="A"); return !!other && !ROYALS.includes(other.rank); }
    return isComboSameRank(cards);
  }
  if(hasA) return false;
  return isComboSameRank(cards);
}

function applyPlay(){
  const sel=selected();
  if(!isValidPlay(sel)){ alert("Invalid selection. Valid plays: single card; one non‑Ace + one Ace; or same‑rank set totaling ≤10."); return; }
  pushHistory();

  const total=sum(sel.map(cardValue));
  const suits=[...new Set(sel.map(c=>c.suit))];
  const immune=enemyImmuneSuit();

  let draw=0, heal=0, dbl=false, addShield=0;
  for(const s of suits){
    const ok=(s!==immune);
    if(s==="♦" && ok) draw=total;
    if(s==="♥" && ok) heal=total;
    if(s==="♣" && ok) dbl=true;
    if(s==="♠" && ok) addShield=total;
  }

  if(heal>0){
    const moved=[]; shuffle(S.discard);
    for(let i=0;i<heal && S.discard.length;i++) moved.push(S.discard.shift());
    S.tavern.push(...moved);
    log(`♥ Heal: moved ${moved.length} from discard under Tavern.`);
  }
  if(draw>0){
    let n=0; while(n<draw && S.hand.length<8 && S.tavern.length){ S.hand.push(S.tavern.shift()); n++; }
    log(`♦ Draw: drew ${n}.`);
  }
  if(addShield>0){ S.spadeShield += addShield; log(`♠ Shield +${addShield} (total ${S.spadeShield}).`); }

  let dmg=total; if(dbl){ log(`♣ Double damage: ${dmg} → ${dmg*2}.`); dmg*=2; }
  S.enemyDamage += dmg;

  S.discard.unshift(...sel);
  S.hand = S.hand.filter(c=>!S.selectedIds.includes(c.id));
  clearSel();

  const base=ENEMY_STATS[S.enemy.rank];
  if(S.enemyDamage>=base.hp){
    const exact=S.enemyDamage===base.hp;
    log(`💥 Defeated ${S.enemy.rank}${S.enemy.suit}${exact?" (exact)":""}.`);
    if(exact){ S.tavern.unshift(clone(S.enemy)); log(`Exact: royal added to TOP of Tavern.`); }
    else{ S.discard.unshift(clone(S.enemy)); }
    S.castle.shift();
    if(S.castle.length===0){ win(); return; }
    S.enemy=clone(S.castle[0]); S.enemyDamage=0; S.spadeShield=0;
    syncUI(); log(`Next enemy: ${S.enemy.rank}${S.enemy.suit}. Your turn.`);
    return;
  }
  sufferDamage();
}

function sufferDamage(){
  const est=currentEnemyStats();
  const need=est.atk;
  if(need<=0){ log(`Enemy attack reduced to 0.`); syncUI(); return; }
  const sorted=S.hand.slice().sort((a,b)=>cardValue(a)-cardValue(b));
  let tot=0,take=[]; for(const c of sorted){ if(tot>=need) break; take.push(c); tot+=cardValue(c); }
  if(tot<need){ lose(); return; }
  S.hand=S.hand.filter(c=>!take.includes(c)); S.discard.unshift(...take);
  log(`☠️ Took ${need} damage. Discarded ${take.length} card(s) [${take.map(c=>c.rank+c.suit).join(", ")}].`);
  syncUI();
}

function yieldTurn(){ pushHistory(); log(`You yield.`); sufferDamage(); }
function flipJester(){
  if(S.jesterFlips<=0){ alert("No Jester flips left."); return; }
  pushHistory(); S.jesterFlips--;
  const n=S.hand.length; S.discard.unshift(...S.hand); S.hand=[];
  let d=0; while(S.hand.length<8 && S.tavern.length){ S.hand.push(S.tavern.shift()); d++; }
  log(`🤡 Jester flip: discarded ${n}, drew ${d}.`); syncUI();
}

function win(){ log(`🏆 Victory! You defeated the last King.`); disableActions(); alert("Victory!"); }
function lose(){ log(`💀 Defeat: you couldn't discard enough.`); disableActions(); alert("Defeat."); }
function disableActions(){ ["playBtn","yieldBtn","flipJesterBtn"].forEach(id=>document.getElementById(id).disabled=true); }

function log(m){ const el=document.getElementById("log"); const p=document.createElement("p"); p.innerHTML=m; el.appendChild(p); el.scrollTop=el.scrollHeight; }
function logClear(){ document.getElementById("log").innerHTML=""; }

function syncUI(){
  const base=ENEMY_STATS[S.enemy.rank], hpLeft=Math.max(0, base.hp - S.enemyDamage);
  document.getElementById("enemyRank").textContent=S.enemy.rank;
  document.getElementById("enemySuit").textContent=S.enemy.suit;
  document.getElementById("enemyCard").className=`card ${COLORS[S.enemy.suit]}`;
  document.getElementById("hpText").textContent=`${hpLeft}/${base.hp}`;
  document.getElementById("atkText").textContent=`${Math.max(0, base.atk - S.spadeShield)} (${base.atk} base)`;
  document.getElementById("immuneSuit").textContent=S.enemy.suit;
  document.getElementById("spadeShield").textContent=S.spadeShield;
  document.getElementById("damageSoFar").textContent=S.enemyDamage;
  document.getElementById("hpBar").style.width=`${Math.round((base.hp-hpLeft)/base.hp*100)}%`;
  document.getElementById("tavernCount").textContent=S.tavern.length;
  document.getElementById("castleCount").textContent=S.castle.length;
  document.getElementById("discardCount").textContent=S.discard.length;
  document.getElementById("jesterFlips").textContent=S.jesterFlips;
  const h=document.getElementById("hand"); h.innerHTML=""; document.getElementById("handCount").textContent=S.hand.length;
  document.getElementById("handEmptyHint").style.display=S.hand.length?"none":"block";
  for(const c of S.hand){ const d=renderCard(c); if(S.selectedIds.includes(c.id)) d.classList.add("selected"); h.appendChild(d); }
}

// Wire up controls
document.getElementById("newGameBtn").addEventListener("click",()=>{ HISTORY=[]; newGame(); },{passive:true});
document.getElementById("playBtn").addEventListener("click",applyPlay,{passive:false});
document.getElementById("yieldBtn").addEventListener("click",yieldTurn,{passive:false});
document.getElementById("flipJesterBtn").addEventListener("click",flipJester,{passive:false});
document.getElementById("undoBtn").addEventListener("click",undo,{passive:false});
document.getElementById("rulesBtn").addEventListener("click",()=>{
  alert("Solo rules (quick):\n\n• Castle: fight J, then Q, then K (within each rank, shuffle suits).\n• Tavern: 2–10 + Aces; hand size 8.\n• Valid plays: single card; one non‑Ace + one Ace; or same‑rank set totaling ≤10.\n• Suit powers apply at total attack and are blocked by immunity (enemy's suit):\n  ♥ Heal — move that many from discard to bottom of Tavern.\n  ♦ Draw — draw that many (up to 8 in hand).\n  ♣ Double — damage ×2.\n  ♠ Shield — reduce enemy attack by that amount (persists vs current enemy).\n• If enemy survives, discard cards totaling ≥ Attack (A=1; J/Q/K in hand=10/15/20).\n• Exact kill: defeated royal to TOP of Tavern; otherwise to discard.\n• Solo: 2 Jester flips (discard hand, refill to 8).");
},{passive:false});

// Auto-start
newGame();
</script>
<script>
// PWA registration
if('serviceWorker' in navigator){ navigator.serviceWorker.register('./sw.js').catch(()=>{}); }
</script>
</body>
</html>
