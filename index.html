<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Ryan's Regicide</title>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b0f14">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    :root{--bg:#0b0f14;--panel:#151c24;--accent:#4da3ff;--text:#e9f2ff;--muted:#9fb4cc;--danger:#ff5d6c;--warn:#ffd166}
    *{box-sizing:border-box}
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;background:#0b0f14;color:var(--text)}
    header{position:sticky;top:0;background:#0c121a;z-index:10;border-bottom:1px solid #1b2633;padding:10px 14px;display:flex;gap:10px;justify-content:space-between;align-items:center}
    h1{font-size:18px;margin:0}
    .btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:700;color:#051017;background:var(--accent)}
    .btn.secondary{background:#1a2533;color:#cfe8ff;border:1px solid #27364a}
    .btn.warn{background:var(--warn)} .btn.danger{background:var(--danger)}
    .container{padding:12px}
    .panel{background:var(--panel);border:1px solid #1a2431;border-radius:16px;padding:12px;margin-bottom:12px}
    .section-title{font-size:13px;text-transform:uppercase;letter-spacing:.15em;color:var(--muted);margin:0 0 6px}
    .enemy{display:flex;gap:12px;align-items:center}
    .stat{background:#0e141c;border:1px solid #1f2a3a;padding:10px;border-radius:12px;min-width:84px;text-align:center}
    .stat .label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.18em}
    .stat .value{font-size:18px;font-weight:800;margin-top:4px}
    .meter{height:10px;background:#0c1320;border:1px solid #1b2740;border-radius:999px;overflow:hidden}
    .meter > i{display:block;height:100%;background:linear-gradient(90deg,#4da3ff,#5dffaa);width:0%}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #213146;background:#0e1520;color:var(--muted);font-size:12px}
    .pile{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pile .card-back,.card{width:68px;height:96px;border-radius:12px;border:2px solid #2a3b53;background:linear-gradient(180deg,#182434,#0f1826);display:grid;place-items:center;font-weight:800;box-shadow:0 2px 0 rgba(0,0,0,.4)}
    .card-back::after{content:"🂠";font-size:20px;filter:drop-shadow(0 1px 0 #000)}
    .counts{font-size:12px;color:var(--muted)}
    .hand{display:flex;gap:10px;overflow-x:auto;padding:10px 6px;min-height:110px;background:rgba(255,255,255,.03);border-radius:12px;border:1px solid #1a2431}
    .card{position:relative;user-select:none}
    .card .rank{position:absolute;left:6px;top:6px;font-size:18.4px;font-weight:900;text-shadow:0 1px 0 #000}
    .card .suit{font-size:29.9px;filter:drop-shadow(0 1px 0 #000)}
    .card.red{color:#ffd0d8} .card.black{color:#e5f1ff}
    .card.selected{outline:3px solid var(--accent);transform:translateY(-4px)}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}
    .log{max-height:36vh;overflow:auto;font-size:13px;line-height:1.35;padding-right:4px}
    .log p{margin:.4em 0}
    button,.btn{pointer-events:auto;touch-action:manipulation}
  </style>
</head>
<body>
<header>
  <h1>Ryan's Regicide</h1>
  <button class="btn" id="newGameBtn">New Game</button>
</header>

<div class="container">
  <div class="panel">
    <p class="section-title">Enemy</p>
    <div class="enemy">
      <div class="card" id="enemyCard" aria-label="Enemy card">
        <div class="rank" id="enemyRank">J</div><div class="suit" id="enemySuit">♣</div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div class="stat"><div class="label">Health</div><div class="value" id="hpText">20</div><div class="meter"><i id="hpBar"></i></div></div>
        <div class="stat"><div class="label">Attack</div><div class="value" id="atkText">10</div><div class="label" id="shieldHint"></div></div>
      </div>
    </div>
    <div class="pile" style="margin-top:10px">
      <span class="badge">Immunity: <b id="immuneSuit">♣</b></span>
      <span class="badge">Spade shield: <b id="spadeShield">0</b></span>
      <span class="badge">Damage dealt: <b id="damageSoFar">0</b></span>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Tavern, Castle & Discard</p>
    <div class="pile">
      <div class="card-back"></div><div class="counts">Tavern: <b id="tavernCount">0</b></div>
      <div class="card-back"></div><div class="counts">Castle: <b id="castleCount">12</b></div>
      <div class="card-back"></div><div class="counts">Discard: <b id="discardCount">0</b></div>
      <span class="badge">Jester flips: <b id="jesterFlips">2</b></span>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Your Hand (tap to select) — <span class="counts">Count: <b id="handCount">0</b></span></p>
    <div class="hand" id="hand" aria-label="Your hand"></div>
    <div class="counts" id="handEmptyHint" style="display:none;margin-top:6px">Your hand is empty. Use ♦ draw or a Jester flip to refill to 8.</div>
  </div>

  <div class="panel">
    <p class="section-title">Actions</p>
    <div class="toolbar">
      <button class="btn" id="playBtn">Play Selected</button>
      <button class="btn secondary" id="yieldBtn">Yield (take damage)</button>
      <button class="btn warn" id="flipJesterBtn">Flip Jester</button>
      <button class="btn danger" id="undoBtn">Undo</button>
      <button class="btn secondary" id="rulesBtn">Rules</button>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Log</p>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
const SUITS=["♣","♦","♥","♠"], COLORS={"♣":"black","♠":"black","♦":"red","♥":"red"};
const RANKS=["2","3","4","5","6","7","8","9","10","A"], ROYALS=["J","Q","K"];
const ENEMY_STATS={J:{hp:20,atk:10},Q:{hp:30,atk:15},K:{hp:40,atk:20}}, MAX_HAND=8;
const sum=a=>a.reduce((x,y)=>x+y,0), clone=o=>JSON.parse(JSON.stringify(o));
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a}
function cardValue(c){if(ROYALS.includes(c.rank))return c.rank==="J"?10:c.rank==="Q"?15:20;if(c.rank==="A")return 1;return parseInt(c.rank,10)}
function renderCard(c){const d=document.createElement("div");d.className=`card ${COLORS[c.suit]}`;d.dataset.id=c.id;
  d.innerHTML=`<div class="rank">${c.rank}</div><div class="suit">${c.suit}</div>`;
  d.addEventListener("click",()=>toggleSelect(c.id),{passive:true});return d}
let S=null,HISTORY=[];
function pushHistory(){HISTORY.push(clone(S));if(HISTORY.length>80)HISTORY.shift()}
function undo(){if(HISTORY.length){S=HISTORY.pop();syncUI(true)}}
function newGame(){
  const j=shuffle(SUITS.map(s=>({rank:"J",suit:s,id:`J${s}`}))),
        q=shuffle(SUITS.map(s=>({rank:"Q",suit:s,id:`Q${s}`}))),
        k=shuffle(SUITS.map(s=>({rank:"K",suit:s,id:`K${s}`})));
  const castle=[...j,...q,...k]; let tavern=[];
  for(const r of RANKS) for(const s of SUITS) tavern.push({rank:r,suit:s,id:`${r}${s}-${Math.random().toString(36).slice(2,7)}`});
  shuffle(tavern); const hand=[]; while(hand.length<MAX_HAND&&tavern.length) hand.push(tavern.shift());
  S={tavern,castle,discard:[],hand,enemy:clone(castle[0]),enemyDamage:0,spadeShield:0,jesterFlips:2,selectedIds:[]};
  logClear(); log(`New game. First enemy: ${S.enemy.rank}${S.enemy.suit}.`); syncUI();
}
function currentEnemyStats(){const b=ENEMY_STATS[S.enemy.rank];return{hp:b.hp,atk:Math.max(0,b.atk-S.spadeShield)}}
function enemyImmuneSuit(){return S.enemy.suit}
function selected(){return S.hand.filter(c=>S.selectedIds.includes(c.id))}
function clearSel(){S.selectedIds=[]}
function toggleSelect(id){const i=S.selectedIds.indexOf(id); if(i>=0) S.selectedIds.splice(i,1); else S.selectedIds.push(id); syncUI(true)}
function isComboSameRank(cards){if(cards.length<2)return!1;const r=[...new Set(cards.map(c=>c.rank))];if(r.length!==1)return!1; if(r[0]==="A"||ROYALS.includes(r[0]))return!1; return sum(cards.map(cardValue))<=10}
function isValidPlay(cards){
  if(!cards.length)return!1; if(cards.length===1)return!0; const hasA=cards.some(c=>c.rank==="A");
  if(cards.length===2){ if(hasA){const o=cards.find(c=>c.rank!=="A"); return !!o && !ROYALS.includes(o.rank)} return isComboSameRank(cards) }
  if(hasA)return!1; return isComboSameRank(cards)
}
function applyPlay(){
  const sel=selected(); if(!isValidPlay(sel)){alert("Invalid selection.");return} pushHistory();
  const total=sum(sel.map(cardValue)), suits=[...new Set(sel.map(c=>c.suit))], immune=enemyImmuneSuit();
  let draw=0,heal=0,dbl=!1,addShield=0;
  for(const s of suits){const ok=s!==immune; if(s==="♦"&&ok)draw=total; if(s==="♥"&&ok)heal=total; if(s==="♣"&&ok)dbl=!0; if(s==="♠"&&ok)addShield=total}
  if(heal>0){const moved=[];shuffle(S.discard);for(let i=0;i<heal&&S.discard.length;i++)moved.push(S.discard.shift());S.tavern.push(...moved);log(`♥ Heal: moved ${moved.length} from discard under Tavern.`)}
  if(draw>0){let n=0; while(n<draw&&S.hand.length<8&&S.tavern.length){S.hand.push(S.tavern.shift());n++} log(`♦ Draw: drew ${n}.`)}
  if(addShield>0){S.spadeShield+=addShield;log(`♠ Shield +${addShield} (total ${S.spadeShield}).`)}
  let dmg=total; if(dbl){log(`♣ Double damage: ${dmg} → ${dmg*2}.`);dmg*=2}
  S.enemyDamage+=dmg; S.discard.unshift(...sel); S.hand=S.hand.filter(c=>!S.selectedIds.includes(c.id)); clearSel();
  const base=ENEMY_STATS[S.enemy.rank]; if(S.enemyDamage>=base.hp){
    const exact=S.enemyDamage===base.hp; log(`💥 Defeated ${S.enemy.rank}${S.enemy.suit}${exact?" (exact)":""}.`);
    if(exact){S.tavern.unshift(clone(S.enemy));log(`Exact: royal added to TOP of Tavern.`)} else {S.discard.unshift(clone(S.enemy))}
    S.castle.shift(); if(!S.castle.length){win();return} S.enemy=clone(S.castle[0]); S.enemyDamage=0; S.spadeShield=0; syncUI(); log(`Next enemy: ${S.enemy.rank}${S.enemy.suit}. Your turn.`); return
  }
  sufferDamage();
}
function sufferDamage(){
  const est=currentEnemyStats(), need=est.atk; if(need<=0){log(`Enemy attack reduced to 0.`);syncUI();return}
  const sorted=S.hand.slice().sort((a,b)=>cardValue(a)-cardValue(b)); let tot=0,take=[];
  for(const c of sorted){if(tot>=need)break; take.push(c); tot+=cardValue(c)}
  if(tot<need){lose();return}
  S.hand=S.hand.filter(c=>!take.includes(c)); S.discard.unshift(...take); log(`☠️ Took ${need} damage. Discarded ${take.length} card(s) [${take.map(c=>c.rank+c.suit).join(", ")}].`); syncUI()
}
function yieldTurn(){pushHistory();log(`You yield.`);sufferDamage()}
function flipJester(){ if(S.jesterFlips<=0){alert("No Jester flips left.");return} pushHistory(); S.jesterFlips--;
  const n=S.hand.length; S.discard.unshift(...S.hand); S.hand=[]; let d=0; while(S.hand.length<8&&S.tavern.length){S.hand.push(S.tavern.shift());d++}
  log(`🤡 Jester flip: discarded ${n}, drew ${d}.`); syncUI()
}
function win(){log(`🏆 Victory! You defeated the last King.`);disableActions();alert("Victory!")}
function lose(){log(`💀 Defeat: you couldn't discard enough.`);disableActions();alert("Defeat.")}
function disableActions(){["playBtn","yieldBtn","flipJesterBtn"].forEach(id=>document.getElementById(id).disabled=true)}
function log(m){const el=document.getElementById("log");const p=document.createElement("p");p.innerHTML=m;el.appendChild(p);el.scrollTop=el.scrollHeight}
function logClear(){document.getElementById("log").innerHTML=""}
function syncUI(){
  const base=ENEMY_STATS[S.enemy.rank], hpLeft=Math.max(0,base.hp-S.enemyDamage);
  document.getElementById("enemyRank").textContent=S.enemy.rank;
  document.getElementById("enemySuit").textContent=S.enemy.suit;
  document.getElementById("enemyCard").className=`card ${COLORS[S.enemy.suit]}`;
  document.getElementById("hpText").textContent=`${hpLeft}/${base.hp}`;
  document.getElementById("atkText").textContent=`${Math.max(0,base.atk-S.spadeShield)} (${base.atk} base)`;
  document.getElementById("immuneSuit").textContent=S.enemy.suit;
  document.getElementById("spadeShield").textContent=S.spadeShield;
  document.getElementById("damageSoFar").textContent=S.enemyDamage;
  document.getElementById("hpBar").style.width=`${Math.round((base.hp-hpLeft)/base.hp*100)}%`;
  document.getElementById("tavernCount").textContent=S.tavern.length;
  document.getElementById("castleCount").textContent=S.castle.length;
  document.getElementById("discardCount").textContent=S.discard.length;
  document.getElementById("jesterFlips").textContent=S.jesterFlips;
  const h=document.getElementById("hand"); h.innerHTML=""; document.getElementById("handCount").textContent=S.hand.length;
  document.getElementById("handEmptyHint").style.display=S.hand.length?"none":"block";
  for(const c of S.hand){const d=renderCard(c); if(S.selectedIds.includes(c.id)) d.classList.add("selected"); h.appendChild(d)}
}
document.getElementById("newGameBtn").addEventListener("click",()=>{HISTORY=[];newGame()},{passive:true});
document.getElementById("playBtn").addEventListener("click",applyPlay,{passive:false});
document.getElementById("yieldBtn").addEventListener("click",yieldTurn,{passive:false});
document.getElementById("flipJesterBtn").addEventListener("click",flipJester,{passive:false});
document.getElementById("undoBtn").addEventListener("click",undo,{passive:false});
document.getElementById("rulesBtn").addEventListener("click",()=>{alert("Solo rules: combos ≤10; A pairs with 1 card; ♥ heal, ♦ draw, ♣ double, ♠ shield; immunity blocks matching suit.")},{passive:false});
newGame();
</script>

<!-- Updated SW registration for auto-refresh on new code -->
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').then(reg => {
      reg.update?.();
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        if (!window._reloaded) { window._reloaded = true; window.location.reload(); }
      });
    }).catch(console.error);
  });
}
</script>
</body>
</html>
