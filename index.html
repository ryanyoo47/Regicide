<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Ryan's Regicide</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0b0f14">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<style>
  :root{
    --bg:#0b0f14; --panel:#151c24; --accent:#4da3ff; --text:#e9f2ff;
    --muted:#9fb4cc; --danger:#ff5d6c; --success:#5dffaa; --warn:#ffd166;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial;background:#0b0f14;color:var(--text)}
  header{position:sticky;top:0;background:#0c121a;z-index:10;border-bottom:1px solid #1b2633;padding:10px 14px;display:flex;gap:10px;justify-content:space-between;align-items:center}
  h1{font-size:18px;margin:0}
  .btn{appearance:none;border:none;border-radius:12px;padding:12px 14px;font-weight:700;color:#051017;background:var(--accent)}
  .btn.secondary{background:#1a2533;color:#cfe8ff;border:1px solid #27364a}
  .btn.warn{background:var(--warn)} .btn.danger{background:var(--danger)}
  .container{padding:12px}
  .panel{background:var(--panel);border:1px solid #1a2431;border-radius:16px;padding:12px;margin-bottom:12px}
  .section-title{font-size:13px;text-transform:uppercase;letter-spacing:.15em;color:var(--muted);margin:0 0 6px}
  .enemy{display:flex;gap:12px;align-items:center}
  .stat{background:#0e141c;border:1px solid #1f2a3a;padding:10px;border-radius:12px;min-width:84px;text-align:center}
  .stat .label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.18em}
  .stat .value{font-size:18px;font-weight:800;margin-top:4px}
  .meter{height:10px;background:#0c1320;border:1px solid #1b2740;border-radius:999px;overflow:hidden}
  .meter > i{display:block;height:100%;background:linear-gradient(90deg,#4da3ff,#5dffaa);width:0%}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid #213146;background:#0e1520;color:var(--muted);font-size:12px}
  .pile{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pile .card-back,.card{width:68px;height:96px;border-radius:12px;border:2px solid #2a3b53;background:linear-gradient(180deg,#182434,#0f1826);display:grid;place-items:center;font-weight:800;box-shadow:0 2px 0 rgba(0,0,0,.4)}
  .card-back::after{content:"🂠";font-size:20px;filter:drop-shadow(0 1px 0 #000)}
  .counts{font-size:12px;color:var(--muted)}
  .hand{display:flex;gap:10px;overflow-x:auto;padding:10px 6px;min-height:110px;background:rgba(255,255,255,0.03);border-radius:12px;border:1px solid #1a2431}
  .card{position:relative;user-select:none}
  .card .rank{position:absolute;left:6px;top:6px;font-size:16px;font-weight:900;text-shadow:0 1px 0 #000}
  .card .suit{font-size:26px;filter:drop-shadow(0 1px 0 #000)}
  .card.red{color:#ffd0d8} .card.black{color:#e5f1ff}
  .card.selected{outline:3px solid var(--accent);transform:translateY(-4px)}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .log{max-height:36vh;overflow:auto;font-size:13px;line-height:1.35;padding-right:4px}
  .log p{margin:.4em 0}
  button,.btn{pointer-events:auto;touch-action:manipulation}
</style>
</head>
<body>
<header>
  <h1>Ryan's Regicide</h1>
  <button class="btn" id="newGameBtn">New Game</button>
</header>

<div class="container">
  <div class="panel">
    <p class="section-title">Enemy</p>
    <div class="enemy">
      <div class="card" id="enemyCard" aria-label="Enemy card">
        <div class="rank" id="enemyRank">J</div>
        <div class="suit" id="enemySuit">♣</div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div class="stat">
          <div class="label">Health</div>
          <div class="value" id="hpText">20</div>
          <div class="meter"><i id="hpBar"></i></div>
        </div>
        <div class="stat">
          <div class="label">Attack</div>
          <div class="value" id="atkText">10</div>
          <div class="label" id="shieldHint"></div>
        </div>
      </div>
    </div>
    <div class="pile" style="margin-top:10px">
      <span class="badge">Immunity: <b id="immuneSuit">♣</b></span>
      <span class="badge">Spade shield: <b id="spadeShield">0</b></span>
      <span class="badge">Damage dealt: <b id="damageSoFar">0</b></span>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Tavern, Castle & Discard</p>
    <div class="pile">
      <div class="card-back" title="Tavern deck"></div><div class="counts">Tavern: <b id="tavernCount">0</b></div>
      <div class="card-back" title="Castle deck"></div><div class="counts">Castle: <b id="castleCount">12</b></div>
      <div class="card-back" title="Discard"></div><div class="counts">Discard: <b id="discardCount">0</b></div>
      <span class="badge">Jester flips: <b id="jesterFlips">2</b></span>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Your Hand (tap to select) — <span class="counts">Count: <b id="handCount">0</b></span></p>
    <div class="hand" id="hand" aria-label="Your hand"></div>
    <div class="counts" id="handEmptyHint" style="display:none;margin-top:6px">Your hand is empty. Use ♦ draw or a Jester flip to refill to 8.</div>
  </div>

  <div class="panel">
    <p class="section-title">Actions</p>
    <div class="toolbar">
      <button class="btn" id="playBtn">Play Selected</button>
      <button class="btn secondary" id="yieldBtn">Yield (take damage)</button>
      <button class="btn warn" id="flipJesterBtn">Flip Jester</button>
      <button class="btn danger" id="undoBtn">Undo</button>
      <button class="btn secondary" id="rulesBtn">Rules</button>
    </div>
  </div>

  <div class="panel">
    <p class="section-title">Log</p>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
// ===== Core data =====
const SUITS = ["♣","♦","♥","♠"];
const COLORS = {"♣":"black","♠":"black","♦":"red","♥":"red"};
const RANKS = ["2","3","4","5","6","7","8","9","10","A"];
const ROYALS = ["J","Q","K"];
const ENEMY_STATS = { "J":{hp:20, atk:10}, "Q":{hp:30, atk:15}, "K":{hp:40, atk:20} };
const MAX_HAND = 8;

function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a }
function clone(o){ return JSON.parse(JSON.stringify(o)) }
function sum(a){ return a.reduce((x,y)=>x+y,0) }
function cardValue(c){ if(ROYALS.includes(c.rank)) return c.rank==="J"?10:c.rank==="Q"?15:20; if(c.rank==="A") return 1; return parseInt(c.rank,10); }

function renderCard(c){
  const d=document.createElement("div");
  d.className=`card ${COLORS[c.suit]}`;
  d.dataset.id=c.id; d.dataset.rank=c.rank; d.dataset.suit=c.suit;
  const r=document.createElement("div"); r.className="rank"; r.textContent=c.rank;
  const s=document.createElement("div"); s.className="suit"; s.textContent=c.suit;
  d.appendChild(r); d.appendChild(s);
  d.addEventListener("click", ()=>{ toggleSelect(c.id); }, {passive:true});
  return d;
}

// ===== State =====
let S=null, HISTORY=[];
function pushHistory(){ HISTORY.push(clone(S)); if(HISTORY.length>80) HISTORY.shift(); }
function undo(){ if(HISTORY.length){ S=HISTORY.pop(); syncUI(true);} }

function newGame(){
  // Build castle: jacks then queens then kings, each group shuffled
  const j=shuffle(SUITS.map(s=>({rank:"J",suit:s,id:`J${s}`})));
  const q=shuffle(SUITS.map(s=>({rank:"Q",suit:s,id:`Q${s}`})));
  const k=shuffle(SUITS.map(s=>({rank:"K",suit:s,id:`K${s}`})));
  const castle=[...j,...q,...k];

  let tavern=[];
  for(const r of RANKS){ for(const s of SUITS){ tavern.push({rank:r,suit:s,id:`${r}${s}-${Math.random().toString(36).slice(2,7)}`}); } }
  shuffle(tavern);

  const hand=[]; while(hand.length<MAX_HAND && tavern.length) hand.push(tavern.shift());

  S={ tavern, castle, discard:[], hand,
      enemy: clone(castle[0]), enemyDamage:0, spadeShield:0, jesterFlips:2,
      selectedIds:[] };
  logClear(); log(`New game. First enemy: ${S.enemy.rank}${S.enemy.suit}.`);
  syncUI();
}

function currentEnemyStats(){ const b=ENEMY_STATS[S.enemy.rank]; return {hp:b.hp, atk:Math.max(0,b.atk - S.spadeShield)} }
function enemyImmuneSuit(){ return S.enemy.suit }

function toggleSelect(id){
  const i=S.selectedIds.indexOf(id);
  if(i>=0) S.selectedIds.splice(i,1); else S.selectedIds.push(id);
  syncUI(true);
}

function isComboSameRank(cards){
  if(cards.length<2) return false;
  const r=[...new Set(cards.map(c=>c.rank))]; if(r.length!==1) return false;
  if(r[0]==="A" || ROYALS.includes(r[0])) return false;
  return sum(cards.map(cardValue))<=10;
}

function isValidPlay(cards){
  if(cards.length===0) return false;
  if(cards.length===1) return true;
  const ranks=[...new Set(cards.map(c=>c.rank))];
  const hasA=cards.some(c=>c.rank==="A");
  if(cards.length===2){
    if(hasA){ const other=cards.find(c=>c.rank!=="A"); return !!other && !ROYAL_RANKS.includes(other?.rank); }
    return isComboSameRank(cards);
  }
  if(hasA) return false;
  return isComboSameRank(cards);
}

function selected(){ return S.hand.filter(c=>S.selectedIds.includes(c.id)); }
function clearSel(){ S.selectedIds=[]; }

function applyPlay(){
  const sel=selected();
  if(!isValidPlay(sel)){ alert("Invalid selection. Valid plays: single card; one non‑Ace + one Ace; or same‑rank set totaling ≤10."); return; }
  pushHistory();

  const total=sum(sel.map(cardValue));
  const suits=[...new Set(sel.map(c=>c.suit))];
  const immune=enemyImmuneSuit();

  let draw=0, heal=0, dbl=false, addShield=0;
  for(const s of suits){
    const ok = (s!==immune);
    if(s==="♦" && ok) draw=total;
    if(s==="♥" && ok) heal=total;
    if(s==="♣" && ok) dbl=true;
    if(s==="♠" && ok) addShield=total;
  }

  if(heal>0){
    const moved=[]; shuffle(S.discard);
    for(let i=0;i<heal && S.discard.length;i++) moved.push(S.discard.shift());
    S.tavern.push(...moved);
    log(`♥ Heal: moved ${moved.length} from discard under Tavern.`);
  }
  if(draw>0){
    let n=0; while(n<draw && S.hand.length<8 && S.tavern.length){ S.hand.push(S.tavern.shift()); n++; }
    log(`♦ Draw: drew ${n}.`);
  }
  if(addShield>0){ S.spadeShield += addShield; log(`♠ Shield +${addShield} (total ${S.spadeShield}).`); }

  let dmg=total; if(dbl){ log(`♣ Double damage: ${dmg} → ${dmg*2}.`); dmg*=2; }
  S.enemyDamage += dmg;

  // move played to discard, remove from hand
  S.discard.unshift(...sel);
  S.hand = S.hand.filter(c=>!S.selectedIds.includes(c.id));
  clearSel();

  const base=ENEMY_STATS[S.enemy.rank];
  if(S.enemyDamage>=base.hp){
    const exact=S.enemyDamage===base.hp;
    log(`💥 Defeated ${S.enemy.rank}${S.enemy.suit}${exact?" (exact)":"")}.`);
    if(exact){ S.tavern.unshift(clone(S.enemy)); log(`Exact: royal added to TOP of Tavern.`); }
    else{ S.discard.unshift(clone(S.enemy)); }
    S.castle.shift();
    if(S.castle.length===0){ win(); return; }
    S.enemy=clone(S.castle[0]); S.enemyDamage=0; S.spadeShield=0;
    syncUI(); log(`Next enemy: ${S.enemy.rank}${S.enemy.suit}. Your turn.`);
    return;
  }

  // Enemy hits back
  sufferDamage();
}

function sufferDamage(){
  const est=currentEnemyStats();
  const need=est.atk;
  if(need<=0){ log(`Enemy attack reduced to 0.`); syncUI(); return; }

  // auto-discard lowest values to meet/exceed need
  const sorted=S.hand.slice().sort((a,b)=>cardValue(a)-cardValue(b));
  let tot=0, take=[];
  for(const c of sorted){ if(tot>=need) break; take.push(c); tot+=cardValue(c); }
  if(tot<need){ lose(); return; }
  S.hand=S.hand.filter(c=>!take.includes(c));
  S.discard.unshift(...take);
  log(`☠️ Took ${need} damage. Discarded ${take.length} card(s) [${take.map(c=>c.rank+c.suit).join(", ")}].`);
  syncUI();
}

function yieldTurn(){ pushHistory(); log(`You yield.`); sufferDamage(); }
function flipJester(){
  if(S.jesterFlips<=0){ alert("No Jester flips left."); return; }
  pushHistory(); S.jesterFlips--;
  const n=S.hand.length; S.discard.unshift(...S.hand); S.hand=[];
  let d=0; while(S.hand.length<8 && S.tavern.length){ S.hand.push(S.tavern.shift()); d++; }
  log(`🤡 Jester flip: discarded ${n}, drew ${d}.`);
  syncUI();
}

function win(){ log(`🏆 Victory! You defeated the last King.`); disableActions(); alert("Victory!"); }
function lose(){ log(`💀 Defeat: you couldn't discard enough.`); disableActions(); alert("Defeat."); }
function disableActions(){ ["playBtn","yieldBtn","flipJesterBtn"].forEach(id=>document.getElementById(id).disabled=true); }

function log(msg){ const el=document.getElementById("log"); const p=document.createElement("p"); p.innerHTML=msg; el.appendChild(p); el.scrollTop=el.scrollHeight; }
function logClear(){ document.getElementById("log").innerHTML=""; }

function syncUI(skipLog){
  const er=document.getElementById("enemyRank"); er.textContent=S.enemy.rank;
  const es=document.getElementById("enemySuit"); es.textContent=S.enemy.suit;
  const ec=document.getElementById("enemyCard"); ec.className=`card ${COLORS[S.enemy.suit]}`;
  const base=ENEMY_STATS[S.enemy.rank]; const hpLeft=Math.max(0, base.hp - S.enemyDamage);
  document.getElementById("hpText").textContent = `${hpLeft}/${base.hp}`;
  document.getElementById("atkText").textContent = `${Math.max(0, base.atk - S.spadeShield)} (${base.atk} base)`;
  document.getElementById("immuneSuit").textContent = S.enemy.suit;
  document.getElementById("spadeShield").textContent = S.spadeShield;
  document.getElementById("damageSoFar").textContent = S.enemyDamage;
  const pct=Math.round((base.hp - hpLeft)/base.hp*100); document.getElementById("hpBar").style.width = `${pct}%`;

  document.getElementById("tavernCount").textContent=S.tavern.length;
  document.getElementById("castleCount").textContent=S.castle.length;
  document.getElementById("discardCount").textContent=S.discard.length;
  document.getElementById("jesterFlips").textContent=S.jesterFlips;

  const hand=document.getElementById("hand"); hand.innerHTML="";
  document.getElementById("handCount").textContent=S.hand.length;
  document.getElementById("handEmptyHint").style.display = S.hand.length? "none":"block";
  for(const c of S.hand){
    const d=renderCard(c);
    if(S.selectedIds.includes(c.id)) d.classList.add("selected");
    hand.appendChild(d);
  }
}

document.getElementById("newGameBtn").addEventListener("click", ()=>{ HISTORY=[]; newGame(); }, {passive:true});
document.getElementById("playBtn").addEventListener("click", applyPlay, {passive:false});
document.getElementById("yieldBtn").addEventListener("click", yieldTurn, {passive:false});
document.getElementById("flipJesterBtn").addEventListener("click", flipJester, {passive:false});
document.getElementById("undoBtn").addEventListener("click", undo, {passive:false});
document.getElementById("rulesBtn").addEventListener("click", ()=>{
  alert("Solo rules summary:\\n\\n• Castle: shuffle suits within each rank; fight J, then Q, then K.\\n• Tavern: 2–10 + Aces, 8-card hand.\\n• Play: single card; one card + one Ace; or same-rank set totaling ≤10.\\n• Powers at total attack (blocked if matching enemy suit): ♥ heal to bottom of Tavern; ♦ draw; ♣ double damage; ♠ add persistent shield.\\n• Enemy survives → discard cards totaling ≥ Attack (J/Q/K in hand worth 10/15/20; A=1).\\n• Exact kill → defeated royal on top of Tavern; otherwise to discard.\\n• 2× Jester flips: discard hand & draw to 8.");
}, {passive:false});

// bootstrap
newGame();
</script>
<script>
// PWA worker
if('serviceWorker' in navigator){ navigator.serviceWorker.register('./sw.js').catch(()=>{}); }
</script>
</body>
</html>
